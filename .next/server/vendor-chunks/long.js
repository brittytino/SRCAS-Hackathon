"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/long";
exports.ids = ["vendor-chunks/long"];
exports.modules = {

/***/ "(ssr)/./node_modules/long/umd/index.js":
/*!****************************************!*\
  !*** ./node_modules/long/umd/index.js ***!
  \****************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\n\nvar Long = function(exports1) {\n    \"use strict\";\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.default = void 0;\n    /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */ // WebAssembly optimizations to do native i64 multiplication and divide\n    var wasm = null;\n    try {\n        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n            0,\n            97,\n            115,\n            109,\n            1,\n            0,\n            0,\n            0,\n            1,\n            13,\n            2,\n            96,\n            0,\n            1,\n            127,\n            96,\n            4,\n            127,\n            127,\n            127,\n            127,\n            1,\n            127,\n            3,\n            7,\n            6,\n            0,\n            1,\n            1,\n            1,\n            1,\n            1,\n            6,\n            6,\n            1,\n            127,\n            1,\n            65,\n            0,\n            11,\n            7,\n            50,\n            6,\n            3,\n            109,\n            117,\n            108,\n            0,\n            1,\n            5,\n            100,\n            105,\n            118,\n            95,\n            115,\n            0,\n            2,\n            5,\n            100,\n            105,\n            118,\n            95,\n            117,\n            0,\n            3,\n            5,\n            114,\n            101,\n            109,\n            95,\n            115,\n            0,\n            4,\n            5,\n            114,\n            101,\n            109,\n            95,\n            117,\n            0,\n            5,\n            8,\n            103,\n            101,\n            116,\n            95,\n            104,\n            105,\n            103,\n            104,\n            0,\n            0,\n            10,\n            191,\n            1,\n            6,\n            4,\n            0,\n            35,\n            0,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            126,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            127,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            128,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            129,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            130,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11\n        ])), {}).exports;\n    } catch (e) {}\n    /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */ function Long(low, high, unsigned) {\n        /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */ this.low = low | 0;\n        /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */ this.high = high | 0;\n        /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */ this.unsigned = !!unsigned;\n    } // The internal representation of a long is the two given signed, 32-bit values.\n    // We use 32-bit pieces because these are the size of integers on which\n    // Javascript performs bit-operations.  For operations like addition and\n    // multiplication, we split each number into 16 bit pieces, which can easily be\n    // multiplied within Javascript's floating-point representation without overflow\n    // or change in sign.\n    //\n    // In the algorithms below, we frequently reduce the negative case to the\n    // positive case by negating the input(s) and then post-processing the result.\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n    // a positive number, it overflows back into a negative).  Not handling this\n    // case would often result in infinite recursion.\n    //\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n    // methods on which they depend.\n    /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */ Long.prototype.__isLong__;\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\n        value: true\n    });\n    /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */ function isLong(obj) {\n        return (obj && obj[\"__isLong__\"]) === true;\n    }\n    /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */ function ctz32(value) {\n        var c = Math.clz32(value & -value);\n        return value ? 31 - c : c;\n    }\n    /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */ Long.isLong = isLong;\n    /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */ var INT_CACHE = {};\n    /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */ var UINT_CACHE = {};\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromInt(value, unsigned) {\n        var obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromInt = fromInt;\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? UZERO : ZERO;\n        if (unsigned) {\n            if (value < 0) return UZERO;\n            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n        }\n        if (value < 0) return fromNumber(-value, unsigned).neg();\n        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromNumber = fromNumber;\n    /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromBits = fromBits;\n    /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n    /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */ function fromString(str, unsigned, radix) {\n        if (str.length === 0) throw Error(\"empty string\");\n        if (typeof unsigned === \"number\") {\n            // For goog.math.long compatibility\n            radix = unsigned;\n            unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        var p;\n        if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n        else if (p === 0) {\n            return fromString(str.substring(1), unsigned, radix).neg();\n        } // Do several (8) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\n        var result = ZERO;\n        for(var i = 0; i < str.length; i += 8){\n            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                var power = fromNumber(pow_dbl(radix, size));\n                result = result.mul(power).add(fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromString = fromString;\n    /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromValue(val, unsigned) {\n        if (typeof val === \"number\") return fromNumber(val, unsigned);\n        if (typeof val === \"string\") return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n        return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */ Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n    // no runtime penalty for these.\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_16_DBL = 1 << 16;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_24_DBL = 1 << 24;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ZERO = fromInt(0);\n    /**\n   * Signed zero.\n   * @type {!Long}\n   */ Long.ZERO = ZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UZERO = fromInt(0, true);\n    /**\n   * Unsigned zero.\n   * @type {!Long}\n   */ Long.UZERO = UZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ONE = fromInt(1);\n    /**\n   * Signed one.\n   * @type {!Long}\n   */ Long.ONE = ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UONE = fromInt(1, true);\n    /**\n   * Unsigned one.\n   * @type {!Long}\n   */ Long.UONE = UONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var NEG_ONE = fromInt(-1);\n    /**\n   * Signed negative one.\n   * @type {!Long}\n   */ Long.NEG_ONE = NEG_ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n    /**\n   * Maximum signed value.\n   * @type {!Long}\n   */ Long.MAX_VALUE = MAX_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n    /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n    /**\n   * Minimum signed value.\n   * @type {!Long}\n   */ Long.MIN_VALUE = MIN_VALUE;\n    /**\n   * @alias Long.prototype\n   * @inner\n   */ var LongPrototype = Long.prototype;\n    /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toInt = function toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toNumber = function toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */ LongPrototype.toString = function toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            // Unsigned Longs are never negative\n            if (this.eq(MIN_VALUE)) {\n                // We need to change the Long value before it can be negated, so we remove\n                // the bottom-most digit in this base and then recurse to do the rest.\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        } // Do several (6) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n        var result = \"\";\n        while(true){\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) return digits + result;\n            else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    };\n    /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */ LongPrototype.getHighBits = function getHighBits() {\n        return this.high;\n    };\n    /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n        return this.high >>> 0;\n    };\n    /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */ LongPrototype.getLowBits = function getLowBits() {\n        return this.low;\n    };\n    /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n        return this.low >>> 0;\n    };\n    /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n        if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        var val = this.high != 0 ? this.high : this.low;\n        for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;\n        return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isZero = function isZero() {\n        return this.high === 0 && this.low === 0;\n    };\n    /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */ LongPrototype.eqz = LongPrototype.isZero;\n    /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isNegative = function isNegative() {\n        return !this.unsigned && this.high < 0;\n    };\n    /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isPositive = function isPositive() {\n        return this.unsigned || this.high >= 0;\n    };\n    /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isOdd = function isOdd() {\n        return (this.low & 1) === 1;\n    };\n    /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isEven = function isEven() {\n        return (this.low & 1) === 0;\n    };\n    /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.equals = function equals(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    };\n    /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.eq = LongPrototype.equals;\n    /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.notEquals = function notEquals(other) {\n        return !this.eq(/* validates */ other);\n    };\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.neq = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ne = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThan = function lessThan(other) {\n        return this.comp(/* validates */ other) < 0;\n    };\n    /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lt = LongPrototype.lessThan;\n    /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n        return this.comp(/* validates */ other) <= 0;\n    };\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.le = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThan = function greaterThan(other) {\n        return this.comp(/* validates */ other) > 0;\n    };\n    /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gt = LongPrototype.greaterThan;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n        return this.comp(/* validates */ other) >= 0;\n    };\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.compare = function compare(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.eq(other)) return 0;\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.comp = LongPrototype.compare;\n    /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */ LongPrototype.negate = function negate() {\n        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n        return this.not().add(ONE);\n    };\n    /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */ LongPrototype.neg = LongPrototype.negate;\n    /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */ LongPrototype.add = function add(addend) {\n        if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = addend.high >>> 16;\n        var b32 = addend.high & 0xFFFF;\n        var b16 = addend.low >>> 16;\n        var b00 = addend.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 + b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.subtract = function subtract(subtrahend) {\n        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    };\n    /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.sub = LongPrototype.subtract;\n    /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.multiply = function multiply(multiplier) {\n        if (this.isZero()) return this;\n        if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n        if (wasm) {\n            var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n        // We can skip products that would overflow.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = multiplier.high >>> 16;\n        var b32 = multiplier.high & 0xFFFF;\n        var b16 = multiplier.low >>> 16;\n        var b00 = multiplier.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.mul = LongPrototype.multiply;\n    /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.divide = function divide(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        if (divisor.isZero()) throw Error(\"division by zero\"); // use wasm support if present\n        if (wasm) {\n            // guard against signed division overflow: the largest\n            // negative number / -1 would be 1 larger than the largest\n            // positive number, due to two's complement.\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                // be consistent with non-wasm code path\n                return this;\n            }\n            var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n        var approx, rem, res;\n        if (!this.unsigned) {\n            // This section is only relevant for signed longs and is derived from the\n            // closure library as a whole.\n            if (this.eq(MIN_VALUE)) {\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n                else if (divisor.eq(MIN_VALUE)) return ONE;\n                else {\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                    var halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(ZERO)) {\n                        return divisor.isNegative() ? ONE : NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = ZERO;\n        } else {\n            // The algorithm below has not been made for unsigned longs. It's therefore\n            // required to take special care of the MSB prior to running it.\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return UZERO;\n            if (divisor.gt(this.shru(1))) return UONE;\n            res = UZERO;\n        } // Repeat the following until the remainder is less than other:  find a\n        // floating-point that approximates remainder / other *from below*, add this\n        // into the result, and subtract it from the remainder.  It is critical that\n        // the approximate value is less than or equal to the real value so that the\n        // remainder never becomes negative.\n        rem = this;\n        while(rem.gte(divisor)){\n            // Approximate the result of division. This may be a little greater or\n            // smaller than the actual value.\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n            // the smallest non-fractional digit, whichever is larger.\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note\n            // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            } // We know the answer can't be zero... and actually, zero would cause\n            // infinite recursion since we would make no progress.\n            if (approxRes.isZero()) approxRes = ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    };\n    /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.div = LongPrototype.divide;\n    /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.modulo = function modulo(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n        if (wasm) {\n            var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    };\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.mod = LongPrototype.modulo;\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.rem = LongPrototype.modulo;\n    /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */ LongPrototype.not = function not() {\n        return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countLeadingZeros = function countLeadingZeros() {\n        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.clz = LongPrototype.countLeadingZeros;\n    /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countTrailingZeros = function countTrailingZeros() {\n        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n    };\n    /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.ctz = LongPrototype.countTrailingZeros;\n    /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.and = function and(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.or = function or(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.xor = function xor(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftLeft = function shiftLeft(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shl = LongPrototype.shiftLeft;\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRight = function shiftRight(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr = LongPrototype.shiftRight;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateLeft = function rotateLeft(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotl = LongPrototype.rotateLeft;\n    /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateRight = function rotateRight(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotr = LongPrototype.rotateRight;\n    /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */ LongPrototype.toSigned = function toSigned() {\n        if (!this.unsigned) return this;\n        return fromBits(this.low, this.high, false);\n    };\n    /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */ LongPrototype.toUnsigned = function toUnsigned() {\n        if (this.unsigned) return this;\n        return fromBits(this.low, this.high, true);\n    };\n    /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */ LongPrototype.toBytes = function toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */ LongPrototype.toBytesLE = function toBytesLE() {\n        var hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    };\n    /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */ LongPrototype.toBytesBE = function toBytesBE() {\n        var hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    };\n    /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    };\n    /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    var _default = Long;\n    exports1.default = _default;\n    return \"default\" in exports1 ? exports1.default : exports1;\n}({});\nif (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n    return Long;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsK0ZBQStCOztBQUMvQixJQUFJQSxPQUFPLFNBQVVDLFFBQU87SUFDMUI7SUFFQUMsT0FBT0MsY0FBYyxDQUFDRixVQUFTLGNBQWM7UUFDM0NHLE9BQU87SUFDVDtJQUNBSCxTQUFRSSxPQUFPLEdBQUcsS0FBSztJQUV2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JDLEdBQ0QsdUVBQXVFO0lBQ3ZFLElBQUlDLE9BQU87SUFFWCxJQUFJO1FBQ0ZBLE9BQU8sSUFBSUMsWUFBWUMsUUFBUSxDQUFDLElBQUlELFlBQVlFLE1BQU0sQ0FBQyxJQUFJQyxXQUFXO1lBQUM7WUFBRztZQUFJO1lBQUs7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBRztZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUs7WUFBRztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBRztZQUFHO1lBQUk7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBRztZQUFJO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUs7U0FBRyxJQUFJLENBQUMsR0FBR1QsT0FBTztJQUNydEMsRUFBRSxPQUFPVSxHQUFHLENBQ1o7SUFDQTs7Ozs7Ozs7O0dBU0MsR0FHRCxTQUFTWCxLQUFLWSxHQUFHLEVBQUVDLElBQUksRUFBRUMsUUFBUTtRQUMvQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNGLEdBQUcsR0FBR0EsTUFBTTtRQUNqQjs7O0tBR0MsR0FFRCxJQUFJLENBQUNDLElBQUksR0FBR0EsT0FBTztRQUNuQjs7O0tBR0MsR0FFRCxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDLENBQUNBO0lBQ3BCLEVBQUUsZ0ZBQWdGO0lBQ2xGLHVFQUF1RTtJQUN2RSx3RUFBd0U7SUFDeEUsK0VBQStFO0lBQy9FLGdGQUFnRjtJQUNoRixxQkFBcUI7SUFDckIsRUFBRTtJQUNGLHlFQUF5RTtJQUN6RSw4RUFBOEU7SUFDOUUsOEVBQThFO0lBQzlFLCtFQUErRTtJQUMvRSw0RUFBNEU7SUFDNUUsaURBQWlEO0lBQ2pELEVBQUU7SUFDRiw4RUFBOEU7SUFDOUUsZ0NBQWdDO0lBRWhDOzs7OztHQUtDLEdBR0RkLEtBQUtlLFNBQVMsQ0FBQ0MsVUFBVTtJQUN6QmQsT0FBT0MsY0FBYyxDQUFDSCxLQUFLZSxTQUFTLEVBQUUsY0FBYztRQUNsRFgsT0FBTztJQUNUO0lBQ0E7Ozs7O0dBS0MsR0FFRCxTQUFTYSxPQUFPQyxHQUFHO1FBQ2pCLE9BQU8sQ0FBQ0EsT0FBT0EsR0FBRyxDQUFDLGFBQWEsTUFBTTtJQUN4QztJQUNBOzs7OztHQUtDLEdBR0QsU0FBU0MsTUFBTWYsS0FBSztRQUNsQixJQUFJZ0IsSUFBSUMsS0FBS0MsS0FBSyxDQUFDbEIsUUFBUSxDQUFDQTtRQUM1QixPQUFPQSxRQUFRLEtBQUtnQixJQUFJQTtJQUMxQjtJQUNBOzs7OztHQUtDLEdBR0RwQixLQUFLaUIsTUFBTSxHQUFHQTtJQUNkOzs7O0dBSUMsR0FFRCxJQUFJTSxZQUFZLENBQUM7SUFDakI7Ozs7R0FJQyxHQUVELElBQUlDLGFBQWEsQ0FBQztJQUNsQjs7Ozs7R0FLQyxHQUVELFNBQVNDLFFBQVFyQixLQUFLLEVBQUVVLFFBQVE7UUFDOUIsSUFBSUksS0FBS1EsV0FBV0M7UUFFcEIsSUFBSWIsVUFBVTtZQUNaVixXQUFXO1lBRVgsSUFBSXVCLFFBQVEsS0FBS3ZCLFNBQVNBLFFBQVEsS0FBSztnQkFDckNzQixZQUFZRixVQUFVLENBQUNwQixNQUFNO2dCQUM3QixJQUFJc0IsV0FBVyxPQUFPQTtZQUN4QjtZQUVBUixNQUFNVSxTQUFTeEIsT0FBTyxHQUFHO1lBQ3pCLElBQUl1QixPQUFPSCxVQUFVLENBQUNwQixNQUFNLEdBQUdjO1lBQy9CLE9BQU9BO1FBQ1QsT0FBTztZQUNMZCxTQUFTO1lBRVQsSUFBSXVCLFFBQVEsQ0FBQyxPQUFPdkIsU0FBU0EsUUFBUSxLQUFLO2dCQUN4Q3NCLFlBQVlILFNBQVMsQ0FBQ25CLE1BQU07Z0JBQzVCLElBQUlzQixXQUFXLE9BQU9BO1lBQ3hCO1lBRUFSLE1BQU1VLFNBQVN4QixPQUFPQSxRQUFRLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDMUMsSUFBSXVCLE9BQU9KLFNBQVMsQ0FBQ25CLE1BQU0sR0FBR2M7WUFDOUIsT0FBT0E7UUFDVDtJQUNGO0lBQ0E7Ozs7OztHQU1DLEdBR0RsQixLQUFLeUIsT0FBTyxHQUFHQTtJQUNmOzs7OztHQUtDLEdBRUQsU0FBU0ksV0FBV3pCLEtBQUssRUFBRVUsUUFBUTtRQUNqQyxJQUFJZ0IsTUFBTTFCLFFBQVEsT0FBT1UsV0FBV2lCLFFBQVFDO1FBRTVDLElBQUlsQixVQUFVO1lBQ1osSUFBSVYsUUFBUSxHQUFHLE9BQU8yQjtZQUN0QixJQUFJM0IsU0FBUzZCLGdCQUFnQixPQUFPQztRQUN0QyxPQUFPO1lBQ0wsSUFBSTlCLFNBQVMsQ0FBQytCLGdCQUFnQixPQUFPQztZQUNyQyxJQUFJaEMsUUFBUSxLQUFLK0IsZ0JBQWdCLE9BQU9FO1FBQzFDO1FBRUEsSUFBSWpDLFFBQVEsR0FBRyxPQUFPeUIsV0FBVyxDQUFDekIsT0FBT1UsVUFBVXdCLEdBQUc7UUFDdEQsT0FBT1YsU0FBU3hCLFFBQVFtQyxpQkFBaUIsR0FBR25DLFFBQVFtQyxpQkFBaUIsR0FBR3pCO0lBQzFFO0lBQ0E7Ozs7OztHQU1DLEdBR0RkLEtBQUs2QixVQUFVLEdBQUdBO0lBQ2xCOzs7Ozs7R0FNQyxHQUVELFNBQVNELFNBQVNZLE9BQU8sRUFBRUMsUUFBUSxFQUFFM0IsUUFBUTtRQUMzQyxPQUFPLElBQUlkLEtBQUt3QyxTQUFTQyxVQUFVM0I7SUFDckM7SUFDQTs7Ozs7Ozs7R0FRQyxHQUdEZCxLQUFLNEIsUUFBUSxHQUFHQTtJQUNoQjs7Ozs7O0dBTUMsR0FFRCxJQUFJYyxVQUFVckIsS0FBS3NCLEdBQUcsRUFBRSw2QkFBNkI7SUFFckQ7Ozs7OztHQU1DLEdBRUQsU0FBU0MsV0FBV0MsR0FBRyxFQUFFL0IsUUFBUSxFQUFFZ0MsS0FBSztRQUN0QyxJQUFJRCxJQUFJRSxNQUFNLEtBQUssR0FBRyxNQUFNQyxNQUFNO1FBRWxDLElBQUksT0FBT2xDLGFBQWEsVUFBVTtZQUNoQyxtQ0FBbUM7WUFDbkNnQyxRQUFRaEM7WUFDUkEsV0FBVztRQUNiLE9BQU87WUFDTEEsV0FBVyxDQUFDLENBQUNBO1FBQ2Y7UUFFQSxJQUFJK0IsUUFBUSxTQUFTQSxRQUFRLGNBQWNBLFFBQVEsZUFBZUEsUUFBUSxhQUFhLE9BQU8vQixXQUFXaUIsUUFBUUM7UUFDakhjLFFBQVFBLFNBQVM7UUFDakIsSUFBSUEsUUFBUSxLQUFLLEtBQUtBLE9BQU8sTUFBTUcsV0FBVztRQUM5QyxJQUFJQztRQUNKLElBQUksQ0FBQ0EsSUFBSUwsSUFBSU0sT0FBTyxDQUFDLElBQUcsSUFBSyxHQUFHLE1BQU1ILE1BQU07YUFBd0IsSUFBSUUsTUFBTSxHQUFHO1lBQy9FLE9BQU9OLFdBQVdDLElBQUlPLFNBQVMsQ0FBQyxJQUFJdEMsVUFBVWdDLE9BQU9SLEdBQUc7UUFDMUQsRUFBRSw2REFBNkQ7UUFDL0QseURBQXlEO1FBRXpELElBQUllLGVBQWV4QixXQUFXYSxRQUFRSSxPQUFPO1FBQzdDLElBQUlRLFNBQVN0QjtRQUViLElBQUssSUFBSXVCLElBQUksR0FBR0EsSUFBSVYsSUFBSUUsTUFBTSxFQUFFUSxLQUFLLEVBQUc7WUFDdEMsSUFBSUMsT0FBT25DLEtBQUtvQyxHQUFHLENBQUMsR0FBR1osSUFBSUUsTUFBTSxHQUFHUSxJQUNoQ25ELFFBQVFzRCxTQUFTYixJQUFJTyxTQUFTLENBQUNHLEdBQUdBLElBQUlDLE9BQU9WO1lBRWpELElBQUlVLE9BQU8sR0FBRztnQkFDWixJQUFJRyxRQUFROUIsV0FBV2EsUUFBUUksT0FBT1U7Z0JBQ3RDRixTQUFTQSxPQUFPTSxHQUFHLENBQUNELE9BQU9FLEdBQUcsQ0FBQ2hDLFdBQVd6QjtZQUM1QyxPQUFPO2dCQUNMa0QsU0FBU0EsT0FBT00sR0FBRyxDQUFDUDtnQkFDcEJDLFNBQVNBLE9BQU9PLEdBQUcsQ0FBQ2hDLFdBQVd6QjtZQUNqQztRQUNGO1FBRUFrRCxPQUFPeEMsUUFBUSxHQUFHQTtRQUNsQixPQUFPd0M7SUFDVDtJQUNBOzs7Ozs7O0dBT0MsR0FHRHRELEtBQUs0QyxVQUFVLEdBQUdBO0lBQ2xCOzs7Ozs7R0FNQyxHQUVELFNBQVNrQixVQUFVQyxHQUFHLEVBQUVqRCxRQUFRO1FBQzlCLElBQUksT0FBT2lELFFBQVEsVUFBVSxPQUFPbEMsV0FBV2tDLEtBQUtqRDtRQUNwRCxJQUFJLE9BQU9pRCxRQUFRLFVBQVUsT0FBT25CLFdBQVdtQixLQUFLakQsV0FBVyx3REFBd0Q7UUFFdkgsT0FBT2MsU0FBU21DLElBQUluRCxHQUFHLEVBQUVtRCxJQUFJbEQsSUFBSSxFQUFFLE9BQU9DLGFBQWEsWUFBWUEsV0FBV2lELElBQUlqRCxRQUFRO0lBQzVGO0lBQ0E7Ozs7OztHQU1DLEdBR0RkLEtBQUs4RCxTQUFTLEdBQUdBLFdBQVcsbUhBQW1IO0lBQy9JLGdDQUFnQztJQUVoQzs7OztHQUlDLEdBRUQsSUFBSUUsaUJBQWlCLEtBQUs7SUFDMUI7Ozs7R0FJQyxHQUVELElBQUlDLGlCQUFpQixLQUFLO0lBQzFCOzs7O0dBSUMsR0FFRCxJQUFJMUIsaUJBQWlCeUIsaUJBQWlCQTtJQUN0Qzs7OztHQUlDLEdBRUQsSUFBSS9CLGlCQUFpQk0saUJBQWlCQTtJQUN0Qzs7OztHQUlDLEdBRUQsSUFBSUosaUJBQWlCRixpQkFBaUI7SUFDdEM7Ozs7R0FJQyxHQUVELElBQUlpQyxhQUFhekMsUUFBUXdDO0lBQ3pCOzs7R0FHQyxHQUVELElBQUlqQyxPQUFPUCxRQUFRO0lBQ25COzs7R0FHQyxHQUVEekIsS0FBS2dDLElBQUksR0FBR0E7SUFDWjs7O0dBR0MsR0FFRCxJQUFJRCxRQUFRTixRQUFRLEdBQUc7SUFDdkI7OztHQUdDLEdBRUR6QixLQUFLK0IsS0FBSyxHQUFHQTtJQUNiOzs7R0FHQyxHQUVELElBQUlvQyxNQUFNMUMsUUFBUTtJQUNsQjs7O0dBR0MsR0FFRHpCLEtBQUttRSxHQUFHLEdBQUdBO0lBQ1g7OztHQUdDLEdBRUQsSUFBSUMsT0FBTzNDLFFBQVEsR0FBRztJQUN0Qjs7O0dBR0MsR0FFRHpCLEtBQUtvRSxJQUFJLEdBQUdBO0lBQ1o7OztHQUdDLEdBRUQsSUFBSUMsVUFBVTVDLFFBQVEsQ0FBQztJQUN2Qjs7O0dBR0MsR0FFRHpCLEtBQUtxRSxPQUFPLEdBQUdBO0lBQ2Y7OztHQUdDLEdBRUQsSUFBSWhDLFlBQVlULFNBQVMsYUFBYSxHQUFHLGFBQWEsR0FBRztJQUN6RDs7O0dBR0MsR0FFRDVCLEtBQUtxQyxTQUFTLEdBQUdBO0lBQ2pCOzs7R0FHQyxHQUVELElBQUlILHFCQUFxQk4sU0FBUyxhQUFhLEdBQUcsYUFBYSxHQUFHO0lBQ2xFOzs7R0FHQyxHQUVENUIsS0FBS2tDLGtCQUFrQixHQUFHQTtJQUMxQjs7O0dBR0MsR0FFRCxJQUFJRSxZQUFZUixTQUFTLEdBQUcsYUFBYSxHQUFHO0lBQzVDOzs7R0FHQyxHQUVENUIsS0FBS29DLFNBQVMsR0FBR0E7SUFDakI7OztHQUdDLEdBRUQsSUFBSWtDLGdCQUFnQnRFLEtBQUtlLFNBQVM7SUFDbEM7Ozs7R0FJQyxHQUVEdUQsY0FBY0MsS0FBSyxHQUFHLFNBQVNBO1FBQzdCLE9BQU8sSUFBSSxDQUFDekQsUUFBUSxHQUFHLElBQUksQ0FBQ0YsR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDQSxHQUFHO0lBQ2xEO0lBQ0E7Ozs7R0FJQyxHQUdEMEQsY0FBY0UsUUFBUSxHQUFHLFNBQVNBO1FBQ2hDLElBQUksSUFBSSxDQUFDMUQsUUFBUSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUNELElBQUksS0FBSyxLQUFLMEIsaUJBQWtCLEtBQUksQ0FBQzNCLEdBQUcsS0FBSztRQUM3RSxPQUFPLElBQUksQ0FBQ0MsSUFBSSxHQUFHMEIsaUJBQWtCLEtBQUksQ0FBQzNCLEdBQUcsS0FBSztJQUNwRDtJQUNBOzs7Ozs7O0dBT0MsR0FHRDBELGNBQWNHLFFBQVEsR0FBRyxTQUFTQSxTQUFTM0IsS0FBSztRQUM5Q0EsUUFBUUEsU0FBUztRQUNqQixJQUFJQSxRQUFRLEtBQUssS0FBS0EsT0FBTyxNQUFNRyxXQUFXO1FBQzlDLElBQUksSUFBSSxDQUFDeUIsTUFBTSxJQUFJLE9BQU87UUFFMUIsSUFBSSxJQUFJLENBQUNDLFVBQVUsSUFBSTtZQUNyQixvQ0FBb0M7WUFDcEMsSUFBSSxJQUFJLENBQUNDLEVBQUUsQ0FBQ3hDLFlBQVk7Z0JBQ3RCLDBFQUEwRTtnQkFDMUUsc0VBQXNFO2dCQUN0RSxJQUFJeUMsWUFBWWhELFdBQVdpQixRQUN2QmdDLE1BQU0sSUFBSSxDQUFDQSxHQUFHLENBQUNELFlBQ2ZFLE9BQU9ELElBQUlsQixHQUFHLENBQUNpQixXQUFXRyxHQUFHLENBQUMsSUFBSTtnQkFDdEMsT0FBT0YsSUFBSUwsUUFBUSxDQUFDM0IsU0FBU2lDLEtBQUtSLEtBQUssR0FBR0UsUUFBUSxDQUFDM0I7WUFDckQsT0FBTyxPQUFPLE1BQU0sSUFBSSxDQUFDUixHQUFHLEdBQUdtQyxRQUFRLENBQUMzQjtRQUMxQyxFQUFFLDZEQUE2RDtRQUMvRCx5REFBeUQ7UUFHekQsSUFBSU8sZUFBZXhCLFdBQVdhLFFBQVFJLE9BQU8sSUFBSSxJQUFJLENBQUNoQyxRQUFRLEdBQzFEbUUsTUFBTSxJQUFJO1FBQ2QsSUFBSTNCLFNBQVM7UUFFYixNQUFPLEtBQU07WUFDWCxJQUFJNEIsU0FBU0QsSUFBSUgsR0FBRyxDQUFDekIsZUFDakI4QixTQUFTRixJQUFJRCxHQUFHLENBQUNFLE9BQU90QixHQUFHLENBQUNQLGVBQWVrQixLQUFLLE9BQU8sR0FDdkRhLFNBQVNELE9BQU9WLFFBQVEsQ0FBQzNCO1lBQzdCbUMsTUFBTUM7WUFDTixJQUFJRCxJQUFJUCxNQUFNLElBQUksT0FBT1UsU0FBUzlCO2lCQUFZO2dCQUM1QyxNQUFPOEIsT0FBT3JDLE1BQU0sR0FBRyxFQUFHcUMsU0FBUyxNQUFNQTtnQkFFekM5QixTQUFTLEtBQUs4QixTQUFTOUI7WUFDekI7UUFDRjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUdEZ0IsY0FBY2UsV0FBVyxHQUFHLFNBQVNBO1FBQ25DLE9BQU8sSUFBSSxDQUFDeEUsSUFBSTtJQUNsQjtJQUNBOzs7O0dBSUMsR0FHRHlELGNBQWNnQixtQkFBbUIsR0FBRyxTQUFTQTtRQUMzQyxPQUFPLElBQUksQ0FBQ3pFLElBQUksS0FBSztJQUN2QjtJQUNBOzs7O0dBSUMsR0FHRHlELGNBQWNpQixVQUFVLEdBQUcsU0FBU0E7UUFDbEMsT0FBTyxJQUFJLENBQUMzRSxHQUFHO0lBQ2pCO0lBQ0E7Ozs7R0FJQyxHQUdEMEQsY0FBY2tCLGtCQUFrQixHQUFHLFNBQVNBO1FBQzFDLE9BQU8sSUFBSSxDQUFDNUUsR0FBRyxLQUFLO0lBQ3RCO0lBQ0E7Ozs7R0FJQyxHQUdEMEQsY0FBY21CLGFBQWEsR0FBRyxTQUFTQTtRQUNyQyxJQUFJLElBQUksQ0FBQ2QsVUFBVSxJQUNqQixPQUFPLElBQUksQ0FBQ0MsRUFBRSxDQUFDeEMsYUFBYSxLQUFLLElBQUksQ0FBQ0UsR0FBRyxHQUFHbUQsYUFBYTtRQUMzRCxJQUFJMUIsTUFBTSxJQUFJLENBQUNsRCxJQUFJLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksR0FBRyxJQUFJLENBQUNELEdBQUc7UUFFL0MsSUFBSyxJQUFJOEUsTUFBTSxJQUFJQSxNQUFNLEdBQUdBLE1BQU8sSUFBSSxDQUFDM0IsTUFBTSxLQUFLMkIsR0FBRSxLQUFNLEdBQUc7UUFFOUQsT0FBTyxJQUFJLENBQUM3RSxJQUFJLElBQUksSUFBSTZFLE1BQU0sS0FBS0EsTUFBTTtJQUMzQztJQUNBOzs7O0dBSUMsR0FHRHBCLGNBQWNJLE1BQU0sR0FBRyxTQUFTQTtRQUM5QixPQUFPLElBQUksQ0FBQzdELElBQUksS0FBSyxLQUFLLElBQUksQ0FBQ0QsR0FBRyxLQUFLO0lBQ3pDO0lBQ0E7OztHQUdDLEdBR0QwRCxjQUFjcUIsR0FBRyxHQUFHckIsY0FBY0ksTUFBTTtJQUN4Qzs7OztHQUlDLEdBRURKLGNBQWNLLFVBQVUsR0FBRyxTQUFTQTtRQUNsQyxPQUFPLENBQUMsSUFBSSxDQUFDN0QsUUFBUSxJQUFJLElBQUksQ0FBQ0QsSUFBSSxHQUFHO0lBQ3ZDO0lBQ0E7Ozs7R0FJQyxHQUdEeUQsY0FBY3NCLFVBQVUsR0FBRyxTQUFTQTtRQUNsQyxPQUFPLElBQUksQ0FBQzlFLFFBQVEsSUFBSSxJQUFJLENBQUNELElBQUksSUFBSTtJQUN2QztJQUNBOzs7O0dBSUMsR0FHRHlELGNBQWN1QixLQUFLLEdBQUcsU0FBU0E7UUFDN0IsT0FBTyxDQUFDLElBQUksQ0FBQ2pGLEdBQUcsR0FBRyxPQUFPO0lBQzVCO0lBQ0E7Ozs7R0FJQyxHQUdEMEQsY0FBY3dCLE1BQU0sR0FBRyxTQUFTQTtRQUM5QixPQUFPLENBQUMsSUFBSSxDQUFDbEYsR0FBRyxHQUFHLE9BQU87SUFDNUI7SUFDQTs7Ozs7R0FLQyxHQUdEMEQsY0FBY3lCLE1BQU0sR0FBRyxTQUFTQSxPQUFPQyxLQUFLO1FBQzFDLElBQUksQ0FBQy9FLE9BQU8rRSxRQUFRQSxRQUFRbEMsVUFBVWtDO1FBQ3RDLElBQUksSUFBSSxDQUFDbEYsUUFBUSxLQUFLa0YsTUFBTWxGLFFBQVEsSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxPQUFPLEtBQUttRixNQUFNbkYsSUFBSSxLQUFLLE9BQU8sR0FBRyxPQUFPO1FBQ2xHLE9BQU8sSUFBSSxDQUFDQSxJQUFJLEtBQUttRixNQUFNbkYsSUFBSSxJQUFJLElBQUksQ0FBQ0QsR0FBRyxLQUFLb0YsTUFBTXBGLEdBQUc7SUFDM0Q7SUFDQTs7Ozs7R0FLQyxHQUdEMEQsY0FBY00sRUFBRSxHQUFHTixjQUFjeUIsTUFBTTtJQUN2Qzs7Ozs7R0FLQyxHQUVEekIsY0FBYzJCLFNBQVMsR0FBRyxTQUFTQSxVQUFVRCxLQUFLO1FBQ2hELE9BQU8sQ0FBQyxJQUFJLENBQUNwQixFQUFFLENBQ2YsYUFBYSxHQUNib0I7SUFDRjtJQUNBOzs7OztHQUtDLEdBR0QxQixjQUFjNEIsR0FBRyxHQUFHNUIsY0FBYzJCLFNBQVM7SUFDM0M7Ozs7O0dBS0MsR0FFRDNCLGNBQWM2QixFQUFFLEdBQUc3QixjQUFjMkIsU0FBUztJQUMxQzs7Ozs7R0FLQyxHQUVEM0IsY0FBYzhCLFFBQVEsR0FBRyxTQUFTQSxTQUFTSixLQUFLO1FBQzlDLE9BQU8sSUFBSSxDQUFDSyxJQUFJLENBQ2hCLGFBQWEsR0FDYkwsU0FBUztJQUNYO0lBQ0E7Ozs7O0dBS0MsR0FHRDFCLGNBQWNnQyxFQUFFLEdBQUdoQyxjQUFjOEIsUUFBUTtJQUN6Qzs7Ozs7R0FLQyxHQUVEOUIsY0FBY2lDLGVBQWUsR0FBRyxTQUFTQSxnQkFBZ0JQLEtBQUs7UUFDNUQsT0FBTyxJQUFJLENBQUNLLElBQUksQ0FDaEIsYUFBYSxHQUNiTCxVQUFVO0lBQ1o7SUFDQTs7Ozs7R0FLQyxHQUdEMUIsY0FBY2tDLEdBQUcsR0FBR2xDLGNBQWNpQyxlQUFlO0lBQ2pEOzs7OztHQUtDLEdBRURqQyxjQUFjbUMsRUFBRSxHQUFHbkMsY0FBY2lDLGVBQWU7SUFDaEQ7Ozs7O0dBS0MsR0FFRGpDLGNBQWNvQyxXQUFXLEdBQUcsU0FBU0EsWUFBWVYsS0FBSztRQUNwRCxPQUFPLElBQUksQ0FBQ0ssSUFBSSxDQUNoQixhQUFhLEdBQ2JMLFNBQVM7SUFDWDtJQUNBOzs7OztHQUtDLEdBR0QxQixjQUFjcUMsRUFBRSxHQUFHckMsY0FBY29DLFdBQVc7SUFDNUM7Ozs7O0dBS0MsR0FFRHBDLGNBQWNzQyxrQkFBa0IsR0FBRyxTQUFTQSxtQkFBbUJaLEtBQUs7UUFDbEUsT0FBTyxJQUFJLENBQUNLLElBQUksQ0FDaEIsYUFBYSxHQUNiTCxVQUFVO0lBQ1o7SUFDQTs7Ozs7R0FLQyxHQUdEMUIsY0FBY3VDLEdBQUcsR0FBR3ZDLGNBQWNzQyxrQkFBa0I7SUFDcEQ7Ozs7O0dBS0MsR0FFRHRDLGNBQWN3QyxFQUFFLEdBQUd4QyxjQUFjc0Msa0JBQWtCO0lBQ25EOzs7Ozs7R0FNQyxHQUVEdEMsY0FBY3lDLE9BQU8sR0FBRyxTQUFTQSxRQUFRZixLQUFLO1FBQzVDLElBQUksQ0FBQy9FLE9BQU8rRSxRQUFRQSxRQUFRbEMsVUFBVWtDO1FBQ3RDLElBQUksSUFBSSxDQUFDcEIsRUFBRSxDQUFDb0IsUUFBUSxPQUFPO1FBQzNCLElBQUlnQixVQUFVLElBQUksQ0FBQ3JDLFVBQVUsSUFDekJzQyxXQUFXakIsTUFBTXJCLFVBQVU7UUFDL0IsSUFBSXFDLFdBQVcsQ0FBQ0MsVUFBVSxPQUFPLENBQUM7UUFDbEMsSUFBSSxDQUFDRCxXQUFXQyxVQUFVLE9BQU8sR0FBRywyQ0FBMkM7UUFFL0UsSUFBSSxDQUFDLElBQUksQ0FBQ25HLFFBQVEsRUFBRSxPQUFPLElBQUksQ0FBQ2tFLEdBQUcsQ0FBQ2dCLE9BQU9yQixVQUFVLEtBQUssQ0FBQyxJQUFJLEdBQUcsZ0RBQWdEO1FBRWxILE9BQU9xQixNQUFNbkYsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDQSxJQUFJLEtBQUssS0FBS21GLE1BQU1uRixJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJLElBQUltRixNQUFNcEYsR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDQSxHQUFHLEtBQUssSUFBSSxDQUFDLElBQUk7SUFDbkg7SUFDQTs7Ozs7O0dBTUMsR0FHRDBELGNBQWMrQixJQUFJLEdBQUcvQixjQUFjeUMsT0FBTztJQUMxQzs7OztHQUlDLEdBRUR6QyxjQUFjNEMsTUFBTSxHQUFHLFNBQVNBO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUNwRyxRQUFRLElBQUksSUFBSSxDQUFDOEQsRUFBRSxDQUFDeEMsWUFBWSxPQUFPQTtRQUNqRCxPQUFPLElBQUksQ0FBQytFLEdBQUcsR0FBR3RELEdBQUcsQ0FBQ007SUFDeEI7SUFDQTs7OztHQUlDLEdBR0RHLGNBQWNoQyxHQUFHLEdBQUdnQyxjQUFjNEMsTUFBTTtJQUN4Qzs7Ozs7R0FLQyxHQUVENUMsY0FBY1QsR0FBRyxHQUFHLFNBQVNBLElBQUl1RCxNQUFNO1FBQ3JDLElBQUksQ0FBQ25HLE9BQU9tRyxTQUFTQSxTQUFTdEQsVUFBVXNELFNBQVMsd0VBQXdFO1FBRXpILElBQUlDLE1BQU0sSUFBSSxDQUFDeEcsSUFBSSxLQUFLO1FBQ3hCLElBQUl5RyxNQUFNLElBQUksQ0FBQ3pHLElBQUksR0FBRztRQUN0QixJQUFJMEcsTUFBTSxJQUFJLENBQUMzRyxHQUFHLEtBQUs7UUFDdkIsSUFBSTRHLE1BQU0sSUFBSSxDQUFDNUcsR0FBRyxHQUFHO1FBQ3JCLElBQUk2RyxNQUFNTCxPQUFPdkcsSUFBSSxLQUFLO1FBQzFCLElBQUk2RyxNQUFNTixPQUFPdkcsSUFBSSxHQUFHO1FBQ3hCLElBQUk4RyxNQUFNUCxPQUFPeEcsR0FBRyxLQUFLO1FBQ3pCLElBQUlnSCxNQUFNUixPQUFPeEcsR0FBRyxHQUFHO1FBQ3ZCLElBQUlpSCxNQUFNLEdBQ05DLE1BQU0sR0FDTkMsTUFBTSxHQUNOQyxNQUFNO1FBQ1ZBLE9BQU9SLE1BQU1JO1FBQ2JHLE9BQU9DLFFBQVE7UUFDZkEsT0FBTztRQUNQRCxPQUFPUixNQUFNSTtRQUNiRyxPQUFPQyxRQUFRO1FBQ2ZBLE9BQU87UUFDUEQsT0FBT1IsTUFBTUk7UUFDYkcsT0FBT0MsUUFBUTtRQUNmQSxPQUFPO1FBQ1BELE9BQU9SLE1BQU1JO1FBQ2JJLE9BQU87UUFDUCxPQUFPakcsU0FBU21HLE9BQU8sS0FBS0MsS0FBS0gsT0FBTyxLQUFLQyxLQUFLLElBQUksQ0FBQ2hILFFBQVE7SUFDakU7SUFDQTs7Ozs7R0FLQyxHQUdEd0QsY0FBYzJELFFBQVEsR0FBRyxTQUFTQSxTQUFTQyxVQUFVO1FBQ25ELElBQUksQ0FBQ2pILE9BQU9pSCxhQUFhQSxhQUFhcEUsVUFBVW9FO1FBQ2hELE9BQU8sSUFBSSxDQUFDckUsR0FBRyxDQUFDcUUsV0FBVzVGLEdBQUc7SUFDaEM7SUFDQTs7Ozs7R0FLQyxHQUdEZ0MsY0FBY1UsR0FBRyxHQUFHVixjQUFjMkQsUUFBUTtJQUMxQzs7Ozs7R0FLQyxHQUVEM0QsY0FBYzZELFFBQVEsR0FBRyxTQUFTQSxTQUFTQyxVQUFVO1FBQ25ELElBQUksSUFBSSxDQUFDMUQsTUFBTSxJQUFJLE9BQU8sSUFBSTtRQUM5QixJQUFJLENBQUN6RCxPQUFPbUgsYUFBYUEsYUFBYXRFLFVBQVVzRSxhQUFhLDhCQUE4QjtRQUUzRixJQUFJOUgsTUFBTTtZQUNSLElBQUlNLE1BQU1OLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDTSxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUV1SCxXQUFXeEgsR0FBRyxFQUFFd0gsV0FBV3ZILElBQUk7WUFDMUUsT0FBT2UsU0FBU2hCLEtBQUtOLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDUSxRQUFRO1FBQ3hEO1FBRUEsSUFBSXNILFdBQVcxRCxNQUFNLElBQUksT0FBTyxJQUFJLENBQUM1RCxRQUFRLEdBQUdpQixRQUFRQztRQUN4RCxJQUFJLElBQUksQ0FBQzRDLEVBQUUsQ0FBQ3hDLFlBQVksT0FBT2dHLFdBQVd2QyxLQUFLLEtBQUt6RCxZQUFZSjtRQUNoRSxJQUFJb0csV0FBV3hELEVBQUUsQ0FBQ3hDLFlBQVksT0FBTyxJQUFJLENBQUN5RCxLQUFLLEtBQUt6RCxZQUFZSjtRQUVoRSxJQUFJLElBQUksQ0FBQzJDLFVBQVUsSUFBSTtZQUNyQixJQUFJeUQsV0FBV3pELFVBQVUsSUFBSSxPQUFPLElBQUksQ0FBQ3JDLEdBQUcsR0FBR3NCLEdBQUcsQ0FBQ3dFLFdBQVc5RixHQUFHO2lCQUFTLE9BQU8sSUFBSSxDQUFDQSxHQUFHLEdBQUdzQixHQUFHLENBQUN3RSxZQUFZOUYsR0FBRztRQUNqSCxPQUFPLElBQUk4RixXQUFXekQsVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDZixHQUFHLENBQUN3RSxXQUFXOUYsR0FBRyxJQUFJQSxHQUFHLElBQUksb0RBQW9EO1FBR2pJLElBQUksSUFBSSxDQUFDZ0UsRUFBRSxDQUFDcEMsZUFBZWtFLFdBQVc5QixFQUFFLENBQUNwQyxhQUFhLE9BQU9yQyxXQUFXLElBQUksQ0FBQzJDLFFBQVEsS0FBSzRELFdBQVc1RCxRQUFRLElBQUksSUFBSSxDQUFDMUQsUUFBUSxHQUFHLDJFQUEyRTtRQUM1TSw0Q0FBNEM7UUFFNUMsSUFBSXVHLE1BQU0sSUFBSSxDQUFDeEcsSUFBSSxLQUFLO1FBQ3hCLElBQUl5RyxNQUFNLElBQUksQ0FBQ3pHLElBQUksR0FBRztRQUN0QixJQUFJMEcsTUFBTSxJQUFJLENBQUMzRyxHQUFHLEtBQUs7UUFDdkIsSUFBSTRHLE1BQU0sSUFBSSxDQUFDNUcsR0FBRyxHQUFHO1FBQ3JCLElBQUk2RyxNQUFNVyxXQUFXdkgsSUFBSSxLQUFLO1FBQzlCLElBQUk2RyxNQUFNVSxXQUFXdkgsSUFBSSxHQUFHO1FBQzVCLElBQUk4RyxNQUFNUyxXQUFXeEgsR0FBRyxLQUFLO1FBQzdCLElBQUlnSCxNQUFNUSxXQUFXeEgsR0FBRyxHQUFHO1FBQzNCLElBQUlpSCxNQUFNLEdBQ05DLE1BQU0sR0FDTkMsTUFBTSxHQUNOQyxNQUFNO1FBQ1ZBLE9BQU9SLE1BQU1JO1FBQ2JHLE9BQU9DLFFBQVE7UUFDZkEsT0FBTztRQUNQRCxPQUFPUixNQUFNSztRQUNiRSxPQUFPQyxRQUFRO1FBQ2ZBLE9BQU87UUFDUEEsT0FBT1AsTUFBTUc7UUFDYkcsT0FBT0MsUUFBUTtRQUNmQSxPQUFPO1FBQ1BELE9BQU9SLE1BQU1NO1FBQ2JDLE9BQU9DLFFBQVE7UUFDZkEsT0FBTztRQUNQQSxPQUFPUCxNQUFNSTtRQUNiRSxPQUFPQyxRQUFRO1FBQ2ZBLE9BQU87UUFDUEEsT0FBT04sTUFBTUU7UUFDYkcsT0FBT0MsUUFBUTtRQUNmQSxPQUFPO1FBQ1BELE9BQU9SLE1BQU1PLE1BQU1OLE1BQU1LLE1BQU1KLE1BQU1HLE1BQU1GLE1BQU1DO1FBQ2pESSxPQUFPO1FBQ1AsT0FBT2pHLFNBQVNtRyxPQUFPLEtBQUtDLEtBQUtILE9BQU8sS0FBS0MsS0FBSyxJQUFJLENBQUNoSCxRQUFRO0lBQ2pFO0lBQ0E7Ozs7O0dBS0MsR0FHRHdELGNBQWNWLEdBQUcsR0FBR1UsY0FBYzZELFFBQVE7SUFDMUM7Ozs7OztHQU1DLEdBRUQ3RCxjQUFjK0QsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLE9BQU87UUFDNUMsSUFBSSxDQUFDckgsT0FBT3FILFVBQVVBLFVBQVV4RSxVQUFVd0U7UUFDMUMsSUFBSUEsUUFBUTVELE1BQU0sSUFBSSxNQUFNMUIsTUFBTSxxQkFBcUIsOEJBQThCO1FBRXJGLElBQUkxQyxNQUFNO1lBQ1Isc0RBQXNEO1lBQ3RELDBEQUEwRDtZQUMxRCw0Q0FBNEM7WUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQ1EsUUFBUSxJQUFJLElBQUksQ0FBQ0QsSUFBSSxLQUFLLENBQUMsY0FBY3lILFFBQVExSCxHQUFHLEtBQUssQ0FBQyxLQUFLMEgsUUFBUXpILElBQUksS0FBSyxDQUFDLEdBQUc7Z0JBQzVGLHdDQUF3QztnQkFDeEMsT0FBTyxJQUFJO1lBQ2I7WUFFQSxJQUFJRCxNQUFNLENBQUMsSUFBSSxDQUFDRSxRQUFRLEdBQUdSLElBQUksQ0FBQyxRQUFRLEdBQUdBLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDTSxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUV5SCxRQUFRMUgsR0FBRyxFQUFFMEgsUUFBUXpILElBQUk7WUFDeEcsT0FBT2UsU0FBU2hCLEtBQUtOLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDUSxRQUFRO1FBQ3hEO1FBRUEsSUFBSSxJQUFJLENBQUM0RCxNQUFNLElBQUksT0FBTyxJQUFJLENBQUM1RCxRQUFRLEdBQUdpQixRQUFRQztRQUNsRCxJQUFJdUcsUUFBUXRELEtBQUt1RDtRQUVqQixJQUFJLENBQUMsSUFBSSxDQUFDMUgsUUFBUSxFQUFFO1lBQ2xCLHlFQUF5RTtZQUN6RSw4QkFBOEI7WUFDOUIsSUFBSSxJQUFJLENBQUM4RCxFQUFFLENBQUN4QyxZQUFZO2dCQUN0QixJQUFJa0csUUFBUTFELEVBQUUsQ0FBQ1QsUUFBUW1FLFFBQVExRCxFQUFFLENBQUNQLFVBQVUsT0FBT2pDLFdBQVcsc0NBQXNDO3FCQUMvRixJQUFJa0csUUFBUTFELEVBQUUsQ0FBQ3hDLFlBQVksT0FBTytCO3FCQUFTO29CQUM5QyxzRUFBc0U7b0JBQ3RFLElBQUlzRSxXQUFXLElBQUksQ0FBQ0MsR0FBRyxDQUFDO29CQUN4QkgsU0FBU0UsU0FBUzNELEdBQUcsQ0FBQ3dELFNBQVNLLEdBQUcsQ0FBQztvQkFFbkMsSUFBSUosT0FBTzNELEVBQUUsQ0FBQzVDLE9BQU87d0JBQ25CLE9BQU9zRyxRQUFRM0QsVUFBVSxLQUFLUixNQUFNRTtvQkFDdEMsT0FBTzt3QkFDTFksTUFBTSxJQUFJLENBQUNELEdBQUcsQ0FBQ3NELFFBQVExRSxHQUFHLENBQUMyRTt3QkFDM0JDLE1BQU1ELE9BQU8xRSxHQUFHLENBQUNvQixJQUFJSCxHQUFHLENBQUN3RDt3QkFDekIsT0FBT0U7b0JBQ1Q7Z0JBQ0Y7WUFDRixPQUFPLElBQUlGLFFBQVExRCxFQUFFLENBQUN4QyxZQUFZLE9BQU8sSUFBSSxDQUFDdEIsUUFBUSxHQUFHaUIsUUFBUUM7WUFFakUsSUFBSSxJQUFJLENBQUMyQyxVQUFVLElBQUk7Z0JBQ3JCLElBQUkyRCxRQUFRM0QsVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDckMsR0FBRyxHQUFHd0MsR0FBRyxDQUFDd0QsUUFBUWhHLEdBQUc7Z0JBQzNELE9BQU8sSUFBSSxDQUFDQSxHQUFHLEdBQUd3QyxHQUFHLENBQUN3RCxTQUFTaEcsR0FBRztZQUNwQyxPQUFPLElBQUlnRyxRQUFRM0QsVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDRyxHQUFHLENBQUN3RCxRQUFRaEcsR0FBRyxJQUFJQSxHQUFHO1lBRW5Fa0csTUFBTXhHO1FBQ1IsT0FBTztZQUNMLDJFQUEyRTtZQUMzRSxnRUFBZ0U7WUFDaEUsSUFBSSxDQUFDc0csUUFBUXhILFFBQVEsRUFBRXdILFVBQVVBLFFBQVFNLFVBQVU7WUFDbkQsSUFBSU4sUUFBUTNCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsT0FBTzVFO1lBQzdCLElBQUl1RyxRQUFRM0IsRUFBRSxDQUFDLElBQUksQ0FBQ2tDLElBQUksQ0FBQyxLQUN2QixPQUFPekU7WUFDVG9FLE1BQU16RztRQUNSLEVBQUUsdUVBQXVFO1FBQ3pFLDRFQUE0RTtRQUM1RSw0RUFBNEU7UUFDNUUsNEVBQTRFO1FBQzVFLG9DQUFvQztRQUdwQ2tELE1BQU0sSUFBSTtRQUVWLE1BQU9BLElBQUk0QixHQUFHLENBQUN5QixTQUFVO1lBQ3ZCLHNFQUFzRTtZQUN0RSxpQ0FBaUM7WUFDakNDLFNBQVNsSCxLQUFLeUgsR0FBRyxDQUFDLEdBQUd6SCxLQUFLMEgsS0FBSyxDQUFDOUQsSUFBSVQsUUFBUSxLQUFLOEQsUUFBUTlELFFBQVEsTUFBTSw0RUFBNEU7WUFDbkosMERBQTBEO1lBRTFELElBQUl3RSxPQUFPM0gsS0FBSzRILElBQUksQ0FBQzVILEtBQUs2SCxHQUFHLENBQUNYLFVBQVVsSCxLQUFLOEgsR0FBRyxHQUM1Q0MsUUFBUUosUUFBUSxLQUFLLElBQUl0RyxRQUFRLEdBQUdzRyxPQUFPLEtBQzNDLDJFQUEyRTtZQUMvRSxrRUFBa0U7WUFDbEVLLFlBQVl4SCxXQUFXMEcsU0FDbkJlLFlBQVlELFVBQVV6RixHQUFHLENBQUMwRTtZQUU5QixNQUFPZ0IsVUFBVTNFLFVBQVUsTUFBTTJFLFVBQVUzQyxFQUFFLENBQUMxQixLQUFNO2dCQUNsRHNELFVBQVVhO2dCQUNWQyxZQUFZeEgsV0FBVzBHLFFBQVEsSUFBSSxDQUFDekgsUUFBUTtnQkFDNUN3SSxZQUFZRCxVQUFVekYsR0FBRyxDQUFDMEU7WUFDNUIsRUFBRSxxRUFBcUU7WUFDdkUsc0RBQXNEO1lBR3RELElBQUllLFVBQVUzRSxNQUFNLElBQUkyRSxZQUFZbEY7WUFDcENxRSxNQUFNQSxJQUFJM0UsR0FBRyxDQUFDd0Y7WUFDZHBFLE1BQU1BLElBQUlELEdBQUcsQ0FBQ3NFO1FBQ2hCO1FBRUEsT0FBT2Q7SUFDVDtJQUNBOzs7OztHQUtDLEdBR0RsRSxjQUFjUSxHQUFHLEdBQUdSLGNBQWMrRCxNQUFNO0lBQ3hDOzs7OztHQUtDLEdBRUQvRCxjQUFjaUYsTUFBTSxHQUFHLFNBQVNBLE9BQU9qQixPQUFPO1FBQzVDLElBQUksQ0FBQ3JILE9BQU9xSCxVQUFVQSxVQUFVeEUsVUFBVXdFLFVBQVUsOEJBQThCO1FBRWxGLElBQUloSSxNQUFNO1lBQ1IsSUFBSU0sTUFBTSxDQUFDLElBQUksQ0FBQ0UsUUFBUSxHQUFHUixJQUFJLENBQUMsUUFBUSxHQUFHQSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQ00sR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxFQUFFeUgsUUFBUTFILEdBQUcsRUFBRTBILFFBQVF6SCxJQUFJO1lBQ3hHLE9BQU9lLFNBQVNoQixLQUFLTixJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQ1EsUUFBUTtRQUN4RDtRQUVBLE9BQU8sSUFBSSxDQUFDa0UsR0FBRyxDQUFDLElBQUksQ0FBQ0YsR0FBRyxDQUFDd0QsU0FBUzFFLEdBQUcsQ0FBQzBFO0lBQ3hDO0lBQ0E7Ozs7O0dBS0MsR0FHRGhFLGNBQWNrRixHQUFHLEdBQUdsRixjQUFjaUYsTUFBTTtJQUN4Qzs7Ozs7R0FLQyxHQUVEakYsY0FBY1csR0FBRyxHQUFHWCxjQUFjaUYsTUFBTTtJQUN4Qzs7OztHQUlDLEdBRURqRixjQUFjNkMsR0FBRyxHQUFHLFNBQVNBO1FBQzNCLE9BQU92RixTQUFTLENBQUMsSUFBSSxDQUFDaEIsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxRQUFRO0lBQ3REO0lBQ0E7Ozs7R0FJQyxHQUdEd0QsY0FBY21GLGlCQUFpQixHQUFHLFNBQVNBO1FBQ3pDLE9BQU8sSUFBSSxDQUFDNUksSUFBSSxHQUFHUSxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDVCxJQUFJLElBQUlRLEtBQUtDLEtBQUssQ0FBQyxJQUFJLENBQUNWLEdBQUcsSUFBSTtJQUNwRTtJQUNBOzs7OztHQUtDLEdBR0QwRCxjQUFjb0YsR0FBRyxHQUFHcEYsY0FBY21GLGlCQUFpQjtJQUNuRDs7OztHQUlDLEdBRURuRixjQUFjcUYsa0JBQWtCLEdBQUcsU0FBU0E7UUFDMUMsT0FBTyxJQUFJLENBQUMvSSxHQUFHLEdBQUdPLE1BQU0sSUFBSSxDQUFDUCxHQUFHLElBQUlPLE1BQU0sSUFBSSxDQUFDTixJQUFJLElBQUk7SUFDekQ7SUFDQTs7Ozs7R0FLQyxHQUdEeUQsY0FBY3NGLEdBQUcsR0FBR3RGLGNBQWNxRixrQkFBa0I7SUFDcEQ7Ozs7O0dBS0MsR0FFRHJGLGNBQWN1RixHQUFHLEdBQUcsU0FBU0EsSUFBSTdELEtBQUs7UUFDcEMsSUFBSSxDQUFDL0UsT0FBTytFLFFBQVFBLFFBQVFsQyxVQUFVa0M7UUFDdEMsT0FBT3BFLFNBQVMsSUFBSSxDQUFDaEIsR0FBRyxHQUFHb0YsTUFBTXBGLEdBQUcsRUFBRSxJQUFJLENBQUNDLElBQUksR0FBR21GLE1BQU1uRixJQUFJLEVBQUUsSUFBSSxDQUFDQyxRQUFRO0lBQzdFO0lBQ0E7Ozs7O0dBS0MsR0FHRHdELGNBQWN3RixFQUFFLEdBQUcsU0FBU0EsR0FBRzlELEtBQUs7UUFDbEMsSUFBSSxDQUFDL0UsT0FBTytFLFFBQVFBLFFBQVFsQyxVQUFVa0M7UUFDdEMsT0FBT3BFLFNBQVMsSUFBSSxDQUFDaEIsR0FBRyxHQUFHb0YsTUFBTXBGLEdBQUcsRUFBRSxJQUFJLENBQUNDLElBQUksR0FBR21GLE1BQU1uRixJQUFJLEVBQUUsSUFBSSxDQUFDQyxRQUFRO0lBQzdFO0lBQ0E7Ozs7O0dBS0MsR0FHRHdELGNBQWN5RixHQUFHLEdBQUcsU0FBU0EsSUFBSS9ELEtBQUs7UUFDcEMsSUFBSSxDQUFDL0UsT0FBTytFLFFBQVFBLFFBQVFsQyxVQUFVa0M7UUFDdEMsT0FBT3BFLFNBQVMsSUFBSSxDQUFDaEIsR0FBRyxHQUFHb0YsTUFBTXBGLEdBQUcsRUFBRSxJQUFJLENBQUNDLElBQUksR0FBR21GLE1BQU1uRixJQUFJLEVBQUUsSUFBSSxDQUFDQyxRQUFRO0lBQzdFO0lBQ0E7Ozs7O0dBS0MsR0FHRHdELGNBQWMwRixTQUFTLEdBQUcsU0FBU0EsVUFBVUMsT0FBTztRQUNsRCxJQUFJaEosT0FBT2dKLFVBQVVBLFVBQVVBLFFBQVExRixLQUFLO1FBQzVDLElBQUksQ0FBQzBGLFdBQVcsRUFBQyxNQUFPLEdBQUcsT0FBTyxJQUFJO2FBQU0sSUFBSUEsVUFBVSxJQUFJLE9BQU9ySSxTQUFTLElBQUksQ0FBQ2hCLEdBQUcsSUFBSXFKLFNBQVMsSUFBSSxDQUFDcEosSUFBSSxJQUFJb0osVUFBVSxJQUFJLENBQUNySixHQUFHLEtBQUssS0FBS3FKLFNBQVMsSUFBSSxDQUFDbkosUUFBUTthQUFPLE9BQU9jLFNBQVMsR0FBRyxJQUFJLENBQUNoQixHQUFHLElBQUlxSixVQUFVLElBQUksSUFBSSxDQUFDbkosUUFBUTtJQUNyTztJQUNBOzs7OztHQUtDLEdBR0R3RCxjQUFjcUUsR0FBRyxHQUFHckUsY0FBYzBGLFNBQVM7SUFDM0M7Ozs7O0dBS0MsR0FFRDFGLGNBQWM0RixVQUFVLEdBQUcsU0FBU0EsV0FBV0QsT0FBTztRQUNwRCxJQUFJaEosT0FBT2dKLFVBQVVBLFVBQVVBLFFBQVExRixLQUFLO1FBQzVDLElBQUksQ0FBQzBGLFdBQVcsRUFBQyxNQUFPLEdBQUcsT0FBTyxJQUFJO2FBQU0sSUFBSUEsVUFBVSxJQUFJLE9BQU9ySSxTQUFTLElBQUksQ0FBQ2hCLEdBQUcsS0FBS3FKLFVBQVUsSUFBSSxDQUFDcEosSUFBSSxJQUFJLEtBQUtvSixTQUFTLElBQUksQ0FBQ3BKLElBQUksSUFBSW9KLFNBQVMsSUFBSSxDQUFDbkosUUFBUTthQUFPLE9BQU9jLFNBQVMsSUFBSSxDQUFDZixJQUFJLElBQUlvSixVQUFVLElBQUksSUFBSSxDQUFDcEosSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDQyxRQUFRO0lBQzdQO0lBQ0E7Ozs7O0dBS0MsR0FHRHdELGNBQWNvRSxHQUFHLEdBQUdwRSxjQUFjNEYsVUFBVTtJQUM1Qzs7Ozs7R0FLQyxHQUVENUYsY0FBYzZGLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFtQkYsT0FBTztRQUNwRSxJQUFJaEosT0FBT2dKLFVBQVVBLFVBQVVBLFFBQVExRixLQUFLO1FBQzVDLElBQUksQ0FBQzBGLFdBQVcsRUFBQyxNQUFPLEdBQUcsT0FBTyxJQUFJO1FBQ3RDLElBQUlBLFVBQVUsSUFBSSxPQUFPckksU0FBUyxJQUFJLENBQUNoQixHQUFHLEtBQUtxSixVQUFVLElBQUksQ0FBQ3BKLElBQUksSUFBSSxLQUFLb0osU0FBUyxJQUFJLENBQUNwSixJQUFJLEtBQUtvSixTQUFTLElBQUksQ0FBQ25KLFFBQVE7UUFDeEgsSUFBSW1KLFlBQVksSUFBSSxPQUFPckksU0FBUyxJQUFJLENBQUNmLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQ0MsUUFBUTtRQUMvRCxPQUFPYyxTQUFTLElBQUksQ0FBQ2YsSUFBSSxLQUFLb0osVUFBVSxJQUFJLEdBQUcsSUFBSSxDQUFDbkosUUFBUTtJQUM5RDtJQUNBOzs7OztHQUtDLEdBR0R3RCxjQUFjdUUsSUFBSSxHQUFHdkUsY0FBYzZGLGtCQUFrQjtJQUNyRDs7Ozs7R0FLQyxHQUVEN0YsY0FBYzhGLEtBQUssR0FBRzlGLGNBQWM2RixrQkFBa0I7SUFDdEQ7Ozs7O0dBS0MsR0FFRDdGLGNBQWMrRixVQUFVLEdBQUcsU0FBU0EsV0FBV0osT0FBTztRQUNwRCxJQUFJSztRQUNKLElBQUlySixPQUFPZ0osVUFBVUEsVUFBVUEsUUFBUTFGLEtBQUs7UUFDNUMsSUFBSSxDQUFDMEYsV0FBVyxFQUFDLE1BQU8sR0FBRyxPQUFPLElBQUk7UUFDdEMsSUFBSUEsWUFBWSxJQUFJLE9BQU9ySSxTQUFTLElBQUksQ0FBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQ0QsR0FBRyxFQUFFLElBQUksQ0FBQ0UsUUFBUTtRQUV0RSxJQUFJbUosVUFBVSxJQUFJO1lBQ2hCSyxJQUFJLEtBQUtMO1lBQ1QsT0FBT3JJLFNBQVMsSUFBSSxDQUFDaEIsR0FBRyxJQUFJcUosVUFBVSxJQUFJLENBQUNwSixJQUFJLEtBQUt5SixHQUFHLElBQUksQ0FBQ3pKLElBQUksSUFBSW9KLFVBQVUsSUFBSSxDQUFDckosR0FBRyxLQUFLMEosR0FBRyxJQUFJLENBQUN4SixRQUFRO1FBQzdHO1FBRUFtSixXQUFXO1FBQ1hLLElBQUksS0FBS0w7UUFDVCxPQUFPckksU0FBUyxJQUFJLENBQUNmLElBQUksSUFBSW9KLFVBQVUsSUFBSSxDQUFDckosR0FBRyxLQUFLMEosR0FBRyxJQUFJLENBQUMxSixHQUFHLElBQUlxSixVQUFVLElBQUksQ0FBQ3BKLElBQUksS0FBS3lKLEdBQUcsSUFBSSxDQUFDeEosUUFBUTtJQUM3RztJQUNBOzs7OztHQUtDLEdBR0R3RCxjQUFjaUcsSUFBSSxHQUFHakcsY0FBYytGLFVBQVU7SUFDN0M7Ozs7O0dBS0MsR0FFRC9GLGNBQWNrRyxXQUFXLEdBQUcsU0FBU0EsWUFBWVAsT0FBTztRQUN0RCxJQUFJSztRQUNKLElBQUlySixPQUFPZ0osVUFBVUEsVUFBVUEsUUFBUTFGLEtBQUs7UUFDNUMsSUFBSSxDQUFDMEYsV0FBVyxFQUFDLE1BQU8sR0FBRyxPQUFPLElBQUk7UUFDdEMsSUFBSUEsWUFBWSxJQUFJLE9BQU9ySSxTQUFTLElBQUksQ0FBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQ0QsR0FBRyxFQUFFLElBQUksQ0FBQ0UsUUFBUTtRQUV0RSxJQUFJbUosVUFBVSxJQUFJO1lBQ2hCSyxJQUFJLEtBQUtMO1lBQ1QsT0FBT3JJLFNBQVMsSUFBSSxDQUFDZixJQUFJLElBQUl5SixJQUFJLElBQUksQ0FBQzFKLEdBQUcsS0FBS3FKLFNBQVMsSUFBSSxDQUFDckosR0FBRyxJQUFJMEosSUFBSSxJQUFJLENBQUN6SixJQUFJLEtBQUtvSixTQUFTLElBQUksQ0FBQ25KLFFBQVE7UUFDN0c7UUFFQW1KLFdBQVc7UUFDWEssSUFBSSxLQUFLTDtRQUNULE9BQU9ySSxTQUFTLElBQUksQ0FBQ2hCLEdBQUcsSUFBSTBKLElBQUksSUFBSSxDQUFDekosSUFBSSxLQUFLb0osU0FBUyxJQUFJLENBQUNwSixJQUFJLElBQUl5SixJQUFJLElBQUksQ0FBQzFKLEdBQUcsS0FBS3FKLFNBQVMsSUFBSSxDQUFDbkosUUFBUTtJQUM3RztJQUNBOzs7OztHQUtDLEdBR0R3RCxjQUFjbUcsSUFBSSxHQUFHbkcsY0FBY2tHLFdBQVc7SUFDOUM7Ozs7R0FJQyxHQUVEbEcsY0FBY29HLFFBQVEsR0FBRyxTQUFTQTtRQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDNUosUUFBUSxFQUFFLE9BQU8sSUFBSTtRQUMvQixPQUFPYyxTQUFTLElBQUksQ0FBQ2hCLEdBQUcsRUFBRSxJQUFJLENBQUNDLElBQUksRUFBRTtJQUN2QztJQUNBOzs7O0dBSUMsR0FHRHlELGNBQWNzRSxVQUFVLEdBQUcsU0FBU0E7UUFDbEMsSUFBSSxJQUFJLENBQUM5SCxRQUFRLEVBQUUsT0FBTyxJQUFJO1FBQzlCLE9BQU9jLFNBQVMsSUFBSSxDQUFDaEIsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxFQUFFO0lBQ3ZDO0lBQ0E7Ozs7O0dBS0MsR0FHRHlELGNBQWNxRyxPQUFPLEdBQUcsU0FBU0EsUUFBUWxFLEVBQUU7UUFDekMsT0FBT0EsS0FBSyxJQUFJLENBQUNtRSxTQUFTLEtBQUssSUFBSSxDQUFDQyxTQUFTO0lBQy9DO0lBQ0E7Ozs7R0FJQyxHQUdEdkcsY0FBY3NHLFNBQVMsR0FBRyxTQUFTQTtRQUNqQyxJQUFJRSxLQUFLLElBQUksQ0FBQ2pLLElBQUksRUFDZGtLLEtBQUssSUFBSSxDQUFDbkssR0FBRztRQUNqQixPQUFPO1lBQUNtSyxLQUFLO1lBQU1BLE9BQU8sSUFBSTtZQUFNQSxPQUFPLEtBQUs7WUFBTUEsT0FBTztZQUFJRCxLQUFLO1lBQU1BLE9BQU8sSUFBSTtZQUFNQSxPQUFPLEtBQUs7WUFBTUEsT0FBTztTQUFHO0lBQzNIO0lBQ0E7Ozs7R0FJQyxHQUdEeEcsY0FBY3VHLFNBQVMsR0FBRyxTQUFTQTtRQUNqQyxJQUFJQyxLQUFLLElBQUksQ0FBQ2pLLElBQUksRUFDZGtLLEtBQUssSUFBSSxDQUFDbkssR0FBRztRQUNqQixPQUFPO1lBQUNrSyxPQUFPO1lBQUlBLE9BQU8sS0FBSztZQUFNQSxPQUFPLElBQUk7WUFBTUEsS0FBSztZQUFNQyxPQUFPO1lBQUlBLE9BQU8sS0FBSztZQUFNQSxPQUFPLElBQUk7WUFBTUEsS0FBSztTQUFLO0lBQzNIO0lBQ0E7Ozs7OztHQU1DLEdBR0QvSyxLQUFLZ0wsU0FBUyxHQUFHLFNBQVNBLFVBQVVDLEtBQUssRUFBRW5LLFFBQVEsRUFBRTJGLEVBQUU7UUFDckQsT0FBT0EsS0FBS3pHLEtBQUtrTCxXQUFXLENBQUNELE9BQU9uSyxZQUFZZCxLQUFLbUwsV0FBVyxDQUFDRixPQUFPbks7SUFDMUU7SUFDQTs7Ozs7R0FLQyxHQUdEZCxLQUFLa0wsV0FBVyxHQUFHLFNBQVNBLFlBQVlELEtBQUssRUFBRW5LLFFBQVE7UUFDckQsT0FBTyxJQUFJZCxLQUFLaUwsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUUsSUFBSSxJQUFJQSxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQUtBLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBSUEsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUUsSUFBSSxJQUFJQSxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQUtBLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBSW5LO0lBQzFJO0lBQ0E7Ozs7O0dBS0MsR0FHRGQsS0FBS21MLFdBQVcsR0FBRyxTQUFTQSxZQUFZRixLQUFLLEVBQUVuSyxRQUFRO1FBQ3JELE9BQU8sSUFBSWQsS0FBS2lMLEtBQUssQ0FBQyxFQUFFLElBQUksS0FBS0EsS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUFLQSxLQUFLLENBQUMsRUFBRSxJQUFJLElBQUlBLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLElBQUksS0FBS0EsS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUFLQSxLQUFLLENBQUMsRUFBRSxJQUFJLElBQUlBLEtBQUssQ0FBQyxFQUFFLEVBQUVuSztJQUMxSTtJQUVBLElBQUlzSyxXQUFXcEw7SUFDZkMsU0FBUUksT0FBTyxHQUFHK0s7SUFDbEIsT0FBTyxhQUFhbkwsV0FBVUEsU0FBUUksT0FBTyxHQUFHSjtBQUNsRCxFQUFHLENBQUM7QUFDSixJQUFJLElBQTBDLEVBQUVvTCxpQ0FBTyxFQUFFLG1DQUFFO0lBQWEsT0FBT3JMO0FBQU0sQ0FBQztBQUFBLGtHQUFDO0tBQ2xGLEVBQXFGQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tieXRlLy4vbm9kZV9tb2R1bGVzL2xvbmcvdW1kL2luZGV4LmpzP2RjNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR0VORVJBVEVEIEZJTEUuIERPIE5PVCBFRElULlxudmFyIExvbmcgPSAoZnVuY3Rpb24oZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG4gIFxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzXG4gICAqIENvcHlyaWdodCAyMDIwIERhbmllbCBXaXJ0eiAvIFRoZSBsb25nLmpzIEF1dGhvcnMuXG4gICAqXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAqXG4gICAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICpcbiAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgKlxuICAgKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICAgKi9cbiAgLy8gV2ViQXNzZW1ibHkgb3B0aW1pemF0aW9ucyB0byBkbyBuYXRpdmUgaTY0IG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpZGVcbiAgdmFyIHdhc20gPSBudWxsO1xuICBcbiAgdHJ5IHtcbiAgICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoWzAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXSkpLCB7fSkuZXhwb3J0cztcbiAgfSBjYXRjaCAoZSkgey8vIG5vIHdhc20gc3VwcG9ydCA6KFxuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxuICAgKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cbiAgICogQGV4cG9ydHMgTG9uZ1xuICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBcbiAgXG4gIGZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG93ID0gbG93IHwgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gIFxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICBcbiAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgfSAvLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxuICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuICAvLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcbiAgLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxuICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuICAvLyBvciBjaGFuZ2UgaW4gc2lnbi5cbiAgLy9cbiAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuICAvLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cbiAgLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXG4gIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbiAgLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xuICAvLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vXG4gIC8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxuICAvLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxuICBcbiAgLyoqXG4gICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBjb25zdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBpc0xvbmcob2JqKSB7XG4gICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IHZhbHVlIG51bWJlclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBcbiAgZnVuY3Rpb24gY3R6MzIodmFsdWUpIHtcbiAgICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZSA/IDMxIC0gYyA6IGM7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZy5pc0xvbmcgPSBpc0xvbmc7XG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBJTlRfQ0FDSEUgPSB7fTtcbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFVJTlRfQ0FDSEUgPSB7fTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcbiAgXG4gICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICB2YWx1ZSA+Pj49IDA7XG4gIFxuICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1Nikge1xuICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgIH1cbiAgXG4gICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgMCwgdHJ1ZSk7XG4gICAgICBpZiAoY2FjaGUpIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgfD0gMDtcbiAgXG4gICAgICBpZiAoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7XG4gICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgIGlmIChjYWNoZWRPYmopIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICB9XG4gIFxuICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgaWYgKGNhY2hlKSBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUludCA9IGZyb21JbnQ7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgXG4gICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICBpZiAodmFsdWUgPCAwKSByZXR1cm4gVVpFUk87XG4gICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpIHJldHVybiBNSU5fVkFMVUU7XG4gICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKSByZXR1cm4gTUFYX1ZBTFVFO1xuICAgIH1cbiAgXG4gICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxuICBcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcbiAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xuICBcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcbiAgICAgIHJhZGl4ID0gdW5zaWduZWQ7XG4gICAgICB1bnNpZ25lZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgfVxuICBcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcbiAgICB2YXIgcDtcbiAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICAgIH0gLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICBcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XG4gICAgdmFyIHJlc3VsdCA9IFpFUk87XG4gIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XG4gIFxuICAgICAgaWYgKHNpemUgPCA4KSB7XG4gICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcbiAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTsgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcbiAgXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxuICAvLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxuICBcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBaRVJPID0gZnJvbUludCgwKTtcbiAgLyoqXG4gICAqIFNpZ25lZCB6ZXJvLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5aRVJPID0gWkVSTztcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcbiAgLyoqXG4gICAqIFVuc2lnbmVkIHplcm8uXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLlVaRVJPID0gVVpFUk87XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBPTkUgPSBmcm9tSW50KDEpO1xuICAvKipcbiAgICogU2lnbmVkIG9uZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuT05FID0gT05FO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBVbnNpZ25lZCBvbmUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLlVPTkUgPSBVT05FO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xuICAvKipcbiAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuTkVHX09ORSA9IE5FR19PTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGIHwgMCwgMHg3RkZGRkZGRiB8IDAsIGZhbHNlKTtcbiAgLyoqXG4gICAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGIHwgMCwgMHhGRkZGRkZGRiB8IDAsIHRydWUpO1xuICAvKipcbiAgICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcbiAgLyoqXG4gICAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XG4gIC8qKlxuICAgKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xuICAgIGlmICh0aGlzLnVuc2lnbmVkKSByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gJzAnO1xuICBcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxuICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXG4gICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXG4gICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgfSBlbHNlIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9IC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgXG4gIFxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcbiAgICAgICAgcmVtID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gIFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxuICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxuICAgICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICByZW0gPSByZW1EaXY7XG4gICAgICBpZiAocmVtLmlzWmVybygpKSByZXR1cm4gZGlnaXRzICsgcmVzdWx0O2Vsc2Uge1xuICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcbiAgXG4gICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcbiAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKSBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKSBicmVhaztcbiAgXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZSBvciB6ZXJvLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuICF0aGlzLmVxKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA8IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcikgPD0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcikgPj0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIGlmICh0aGlzLmVxKG90aGVyKSkgcmV0dXJuIDA7XG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKSByZXR1cm4gLTE7XG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKSByZXR1cm4gMTsgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICBcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOyAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcbiAgXG4gICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxO1xuICB9O1xuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XG4gIC8qKlxuICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcbiAgfTtcbiAgLyoqXG4gICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xuICAgIGlmICghaXNMb25nKGFkZGVuZCkpIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpOyAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cbiAgXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGM0OCA9IDAsXG4gICAgICAgIGMzMiA9IDAsXG4gICAgICAgIGMxNiA9IDAsXG4gICAgICAgIGMwMCA9IDA7XG4gICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICBjMDAgJj0gMHhGRkZGO1xuICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgYzE2ICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICBjNDggJj0gMHhGRkZGO1xuICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcbiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSkgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7IC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBcbiAgICBpZiAod2FzbSkge1xuICAgICAgdmFyIGxvdyA9IHdhc21bXCJtdWxcIl0odGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG4gIFxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7ZWxzZSByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpOyAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gIFxuICBcbiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKSByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpOyAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxuICBcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGM0OCA9IDAsXG4gICAgICAgIGMzMiA9IDAsXG4gICAgICAgIGMxNiA9IDAsXG4gICAgICAgIGMwMCA9IDA7XG4gICAgYzAwICs9IGEwMCAqIGIwMDtcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICBjMDAgJj0gMHhGRkZGO1xuICAgIGMxNiArPSBhMTYgKiBiMDA7XG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgYzE2ICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTAwICogYjE2O1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEzMiAqIGIwMDtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMTYgKiBiMTY7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTAwICogYjMyO1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgICBjNDggJj0gMHhGRkZGO1xuICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXG4gICAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSkgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTsgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIFxuICAgIGlmICh3YXNtKSB7XG4gICAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcbiAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcbiAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXG4gICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJiBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkge1xuICAgICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJkaXZfdVwiXSA6IHdhc21bXCJkaXZfc1wiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XG4gIFxuICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxuICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXG4gICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSkgcmV0dXJuIE1JTl9WQUxVRTsgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcbiAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKSByZXR1cm4gT05FO2Vsc2Uge1xuICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cbiAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xuICBcbiAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICBcbiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICBcbiAgICAgIHJlcyA9IFpFUk87XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxuICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxuICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKSBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XG4gICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSkgcmV0dXJuIFVaRVJPO1xuICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcbiAgICAgICAgcmV0dXJuIFVPTkU7XG4gICAgICByZXMgPSBVWkVSTztcbiAgICB9IC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXG4gIFxuICBcbiAgICByZW0gPSB0aGlzO1xuICBcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxuICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7IC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcbiAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cbiAgXG4gICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxuICAgICAgICAgIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXG4gICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXG4gICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cbiAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcbiAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICBcbiAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgfSAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcbiAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxuICBcbiAgXG4gICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKSBhcHByb3hSZXMgPSBPTkU7XG4gICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSkgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTsgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIFxuICAgIGlmICh3YXNtKSB7XG4gICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wicmVtX3VcIl0gOiB3YXNtW1wicmVtX3NcIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xuICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBjb3VudCBsZWFkaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50TGVhZGluZ1plcm9zKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPyBNYXRoLmNsejMyKHRoaXMuaGlnaCkgOiBNYXRoLmNsejMyKHRoaXMubG93KSArIDMyO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBjb3VudCBsZWFkaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50TGVhZGluZ1plcm9zfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmNseiA9IExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3M7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcygpIHtcbiAgICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50VHJhaWxpbmdaZXJvc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5jdHogPSBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztlbHNlIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMsIHRoaXMudW5zaWduZWQpO2Vsc2UgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IG51bUJpdHMgLSAzMiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO2Vsc2UgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO2Vsc2UgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gbnVtQml0cyAtIDMyLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUucm90YXRlTGVmdCA9IGZ1bmN0aW9uIHJvdGF0ZUxlZnQobnVtQml0cykge1xuICAgIHZhciBiO1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIFxuICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICBudW1CaXRzIC09IDMyO1xuICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IGIsIHRoaXMubG93IDw8IG51bUJpdHMgfCB0aGlzLmhpZ2ggPj4+IGIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVMZWZ0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUucm90bCA9IExvbmdQcm90b3R5cGUucm90YXRlTGVmdDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodCA9IGZ1bmN0aW9uIHJvdGF0ZVJpZ2h0KG51bUJpdHMpIHtcbiAgICB2YXIgYjtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBcbiAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA8PCBiIHwgdGhpcy5sb3cgPj4+IG51bUJpdHMsIHRoaXMubG93IDw8IGIgfCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgbnVtQml0cyAtPSAzMjtcbiAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBiIHwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgYiB8IHRoaXMubG93ID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZVJpZ2h0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUucm90ciA9IExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQ7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xuICAgIGlmICh0aGlzLnVuc2lnbmVkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHtcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XG4gICAgcmV0dXJuIFtsbyAmIDB4ZmYsIGxvID4+PiA4ICYgMHhmZiwgbG8gPj4+IDE2ICYgMHhmZiwgbG8gPj4+IDI0LCBoaSAmIDB4ZmYsIGhpID4+PiA4ICYgMHhmZiwgaGkgPj4+IDE2ICYgMHhmZiwgaGkgPj4+IDI0XTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XG4gICAgcmV0dXJuIFtoaSA+Pj4gMjQsIGhpID4+PiAxNiAmIDB4ZmYsIGhpID4+PiA4ICYgMHhmZiwgaGkgJiAweGZmLCBsbyA+Pj4gMjQsIGxvID4+PiAxNiAmIDB4ZmYsIGxvID4+PiA4ICYgMHhmZiwgbG8gJiAweGZmXTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgIHJldHVybiBuZXcgTG9uZyhieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LCBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0LCB1bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTtcbiAgfTtcbiAgXG4gIHZhciBfZGVmYXVsdCA9IExvbmc7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuICByZXR1cm4gXCJkZWZhdWx0XCIgaW4gZXhwb3J0cyA/IGV4cG9ydHMuZGVmYXVsdCA6IGV4cG9ydHM7XG59KSh7fSk7XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTG9uZzsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIG1vZHVsZS5leHBvcnRzID0gTG9uZztcbiJdLCJuYW1lcyI6WyJMb25nIiwiZXhwb3J0cyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJkZWZhdWx0Iiwid2FzbSIsIldlYkFzc2VtYmx5IiwiSW5zdGFuY2UiLCJNb2R1bGUiLCJVaW50OEFycmF5IiwiZSIsImxvdyIsImhpZ2giLCJ1bnNpZ25lZCIsInByb3RvdHlwZSIsIl9faXNMb25nX18iLCJpc0xvbmciLCJvYmoiLCJjdHozMiIsImMiLCJNYXRoIiwiY2x6MzIiLCJJTlRfQ0FDSEUiLCJVSU5UX0NBQ0hFIiwiZnJvbUludCIsImNhY2hlZE9iaiIsImNhY2hlIiwiZnJvbUJpdHMiLCJmcm9tTnVtYmVyIiwiaXNOYU4iLCJVWkVSTyIsIlpFUk8iLCJUV09fUFdSXzY0X0RCTCIsIk1BWF9VTlNJR05FRF9WQUxVRSIsIlRXT19QV1JfNjNfREJMIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwibmVnIiwiVFdPX1BXUl8zMl9EQkwiLCJsb3dCaXRzIiwiaGlnaEJpdHMiLCJwb3dfZGJsIiwicG93IiwiZnJvbVN0cmluZyIsInN0ciIsInJhZGl4IiwibGVuZ3RoIiwiRXJyb3IiLCJSYW5nZUVycm9yIiwicCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyYWRpeFRvUG93ZXIiLCJyZXN1bHQiLCJpIiwic2l6ZSIsIm1pbiIsInBhcnNlSW50IiwicG93ZXIiLCJtdWwiLCJhZGQiLCJmcm9tVmFsdWUiLCJ2YWwiLCJUV09fUFdSXzE2X0RCTCIsIlRXT19QV1JfMjRfREJMIiwiVFdPX1BXUl8yNCIsIk9ORSIsIlVPTkUiLCJORUdfT05FIiwiTG9uZ1Byb3RvdHlwZSIsInRvSW50IiwidG9OdW1iZXIiLCJ0b1N0cmluZyIsImlzWmVybyIsImlzTmVnYXRpdmUiLCJlcSIsInJhZGl4TG9uZyIsImRpdiIsInJlbTEiLCJzdWIiLCJyZW0iLCJyZW1EaXYiLCJpbnR2YWwiLCJkaWdpdHMiLCJnZXRIaWdoQml0cyIsImdldEhpZ2hCaXRzVW5zaWduZWQiLCJnZXRMb3dCaXRzIiwiZ2V0TG93Qml0c1Vuc2lnbmVkIiwiZ2V0TnVtQml0c0FicyIsImJpdCIsImVxeiIsImlzUG9zaXRpdmUiLCJpc09kZCIsImlzRXZlbiIsImVxdWFscyIsIm90aGVyIiwibm90RXF1YWxzIiwibmVxIiwibmUiLCJsZXNzVGhhbiIsImNvbXAiLCJsdCIsImxlc3NUaGFuT3JFcXVhbCIsImx0ZSIsImxlIiwiZ3JlYXRlclRoYW4iLCJndCIsImdyZWF0ZXJUaGFuT3JFcXVhbCIsImd0ZSIsImdlIiwiY29tcGFyZSIsInRoaXNOZWciLCJvdGhlck5lZyIsIm5lZ2F0ZSIsIm5vdCIsImFkZGVuZCIsImE0OCIsImEzMiIsImExNiIsImEwMCIsImI0OCIsImIzMiIsImIxNiIsImIwMCIsImM0OCIsImMzMiIsImMxNiIsImMwMCIsInN1YnRyYWN0Iiwic3VidHJhaGVuZCIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsImRpdmlkZSIsImRpdmlzb3IiLCJhcHByb3giLCJyZXMiLCJoYWxmVGhpcyIsInNociIsInNobCIsInRvVW5zaWduZWQiLCJzaHJ1IiwibWF4IiwiZmxvb3IiLCJsb2cyIiwiY2VpbCIsImxvZyIsIkxOMiIsImRlbHRhIiwiYXBwcm94UmVzIiwiYXBwcm94UmVtIiwibW9kdWxvIiwibW9kIiwiY291bnRMZWFkaW5nWmVyb3MiLCJjbHoiLCJjb3VudFRyYWlsaW5nWmVyb3MiLCJjdHoiLCJhbmQiLCJvciIsInhvciIsInNoaWZ0TGVmdCIsIm51bUJpdHMiLCJzaGlmdFJpZ2h0Iiwic2hpZnRSaWdodFVuc2lnbmVkIiwic2hyX3UiLCJyb3RhdGVMZWZ0IiwiYiIsInJvdGwiLCJyb3RhdGVSaWdodCIsInJvdHIiLCJ0b1NpZ25lZCIsInRvQnl0ZXMiLCJ0b0J5dGVzTEUiLCJ0b0J5dGVzQkUiLCJoaSIsImxvIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJmcm9tQnl0ZXNMRSIsImZyb21CeXRlc0JFIiwiX2RlZmF1bHQiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/long/umd/index.js\n");

/***/ })

};
;